#include <stdio.h>
#include <stdlib.h>

#include "groupstuff.h"

/*! \mainpage Reference documentation for IDL-Grouplib

\author Volker Springel \n
        Max-Planck-Institute for Astrophysics \n
        Garching, Germany \n
        volker@mpa-garching.mpg.de \n
\n

This C-library is meant to be called by IDL (or other languages) and
provides an easy-to-use interface for the groupcatalogues generated by
the FOF algorithm of <b>L-GADGET2</b>.
*/

typedef struct
{
  char *s;
}
IDL_STRING;


typedef struct
{
  int npart[6];
  double mass[6];
  double time;
  double redshift;
  int flag_sfr;
  int flag_feedback;
  int npartTotal[6];
  int flag_cooling;
  int num_files;
  double BoxSize;
  double Omega0;
  double OmegaLambda;
  double HubbleParam;
  int flag_stellarage;
  int flag_metals;
  int hashtabsize;
  char fill[84];		/* fills to 256 Bytes */
}
io_header;



typedef struct
{
  int len;
  int file;
  int offset;
}
cat_data;

static double BoxSize;

/*  Expected input values:
 *  char*    Output directory
 *  int      snapshot number
 */
int get_total_number_of_groups(int argc, void *argv[])
{
  int Ngroups, Nids, TotNgroups, NTask, Num;
  char *OutputDir;
  char buf[1000];
  FILE *fd;

  OutputDir = (char *) argv[0];
  Num = *(int *) argv[1];

  sprintf(buf, "%s/group_tab_%03d.0", OutputDir, Num);
  if(!(fd = fopen(buf, "r")))
    {
        printf("path: %s\n",buf);
      return -1;
    }

  fread(&Ngroups, sizeof(int), 1, fd);
  fread(&Nids, sizeof(int), 1, fd);
  fread(&TotNgroups, sizeof(int), 1, fd);
  fread(&NTask, sizeof(int), 1, fd);
  fclose(fd);

  return TotNgroups;
}



int get_number_of_subhalos_in_halo(int argc, void *argv[])
{
  int Ngroups, Nids, TotNgroups, NTask, Num, Nsubhalos, FiNr, GrNr, Subs_in_halo;
  IDL_STRING *idl_s;
  char *OutputDir;
  char buf[1000];
  FILE *fd;

  idl_s = (IDL_STRING *) argv[0];
  OutputDir = idl_s->s;
  Num = *(int *) argv[1];

  FiNr = *(int *) argv[2];
  GrNr = *(int *) argv[3];

  sprintf(buf, "%s/sub_tab_%03d.%d", OutputDir, Num, FiNr);
  if(!(fd = fopen(buf, "r")))
    {
      printf("can't open file `%s'\n", buf);
      return -1;
    }



  fread(&Ngroups, sizeof(int), 1, fd);
  fread(&Nids, sizeof(int), 1, fd);
  fread(&TotNgroups, sizeof(int), 1, fd);
  fread(&NTask, sizeof(int), 1, fd);
  fread(&Nsubhalos, sizeof(int), 1, fd);
  
  fseek(fd, sizeof(int) * GrNr, SEEK_CUR);

  fread(&Subs_in_halo, sizeof(int), 1, fd);

  printf("Subs_in_halo=%d\n", Subs_in_halo);

  fclose(fd);

  return Subs_in_halo;
}



int get_length_of_subhalos_for_halo(int argc, void *argv[])
{
  int Ngroups, Nids, TotNgroups, NTask, Num, Nsubhalos, FiNr, GrNr, Nsubs, *SubLenTab, first_sub;
  IDL_STRING *idl_s;
  char *OutputDir;
  char buf[1000];
  FILE *fd;

  idl_s = (IDL_STRING *) argv[0];
  OutputDir = idl_s->s;
  Num = *(int *) argv[1];

  FiNr = *(int *) argv[2];
  GrNr = *(int *) argv[3];

  Nsubs = *(int *) argv[4];
  SubLenTab = (int *) argv[5];


  sprintf(buf, "%s/sub_tab_%03d.%d", OutputDir, Num, FiNr);
  if(!(fd = fopen(buf, "r")))
    {
      printf("can't open file `%s'\n", buf);
      return -1;
    }



  fread(&Ngroups, sizeof(int), 1, fd);
  fread(&Nids, sizeof(int), 1, fd);
  fread(&TotNgroups, sizeof(int), 1, fd);
  fread(&NTask, sizeof(int), 1, fd);
  fread(&Nsubhalos, sizeof(int), 1, fd);
  
  fseek(fd, sizeof(int) * Ngroups, SEEK_CUR);  

  fseek(fd, sizeof(int) * GrNr, SEEK_CUR);
  fread(&first_sub, sizeof(int), 1, fd);
  fseek(fd, sizeof(int) * (Ngroups - GrNr - 1), SEEK_CUR);


  fseek(fd, sizeof(int) * first_sub, SEEK_CUR);

  fread(SubLenTab, sizeof(int), Nsubs, fd);

  fclose(fd);

  return Nsubs;

}






int get_minimum_group_len(int argc, void *argv[])
{
  int Ngroups, Nids, TotNgroups, NTask, Num, GroupMinLen;
  IDL_STRING *idl_s;
  char *OutputDir;
  char buf[1000];
  FILE *fd;

  idl_s = (IDL_STRING *) argv[0];
  OutputDir = idl_s->s;
  Num = *(int *) argv[1];

  sprintf(buf, "%s/group_tab_%03d.0", OutputDir, Num);
  if(!(fd = fopen(buf, "r")))
    {
      printf("can't open file `%s'\n", buf);
      return -1;
    }

  fread(&Ngroups, sizeof(int), 1, fd);
  fread(&Nids, sizeof(int), 1, fd);
  fread(&TotNgroups, sizeof(int), 1, fd);
  fread(&NTask, sizeof(int), 1, fd);
  fseek(fd, sizeof(int) * Ngroups, SEEK_CUR);	/* skip GroupLen */
  fseek(fd, sizeof(int) * Ngroups, SEEK_CUR);	/* skip GroupOffset */
  fread(&GroupMinLen, sizeof(int), 1, fd);
  fclose(fd);

  return GroupMinLen;
}



int get_groupcount_below_minimum_len(int argc, void *argv[])
{
  int Ngroups, Nids, TotNgroups, NTask, Num, i, filenr, GroupMinLen;
  int *count;
  double *CountBelowMinLen;
  IDL_STRING *idl_s;
  char *OutputDir;
  char buf[1000];
  FILE *fd;

  idl_s = (IDL_STRING *) argv[0];
  OutputDir = idl_s->s;
  Num = *(int *) argv[1];

  CountBelowMinLen = (double *) argv[2];

  sprintf(buf, "%s/group_tab_%03d.0", OutputDir, Num);
  if(!(fd = fopen(buf, "r")))
    {
      printf("can't open file `%s'\n", buf);
      return -1;
    }

  fread(&Ngroups, sizeof(int), 1, fd);
  fread(&Nids, sizeof(int), 1, fd);
  fread(&TotNgroups, sizeof(int), 1, fd);
  fread(&NTask, sizeof(int), 1, fd);
  fseek(fd, sizeof(int) * Ngroups, SEEK_CUR);	/* skip GroupLen */
  fseek(fd, sizeof(int) * Ngroups, SEEK_CUR);	/* skip GroupOffset */
  fread(&GroupMinLen, sizeof(int), 1, fd);
  fclose(fd);


  count = malloc(GroupMinLen * sizeof(int));

  for(i = 0; i < GroupMinLen; i++)
    CountBelowMinLen[i] = 0;

  for(filenr = 0; filenr < NTask; filenr++)
    {
      sprintf(buf, "%s/group_tab_%03d.%d", OutputDir, Num, filenr);
      if(!(fd = fopen(buf, "r")))
	{
	  printf("can't open file `%s'\n", buf);
	  return -1;
	}

      fread(&Ngroups, sizeof(int), 1, fd);
      fread(&Nids, sizeof(int), 1, fd);
      fread(&TotNgroups, sizeof(int), 1, fd);
      fread(&NTask, sizeof(int), 1, fd);
      fseek(fd, sizeof(int) * Ngroups, SEEK_CUR);	/* skip GroupLen */
      fseek(fd, sizeof(int) * Ngroups, SEEK_CUR);	/* skip GroupOffset */
      fread(&GroupMinLen, sizeof(int), 1, fd);
      fread(count, sizeof(int), GroupMinLen, fd);

      for(i = 0; i < GroupMinLen; i++)
	CountBelowMinLen[i] += count[i];

      fclose(fd);
    }

  free(count);

  return GroupMinLen;
}







int get_group_catalogue(int argc, void *argv[])
{
  int Ngroups, Nids, TotNgroups, NTask, Num, count, i, filenr;
  int *GroupLen, *GroupFileNr, *GroupNr;
  cat_data *temp;
  char *OutputDir;
  char buf[1000];
  FILE *fd;

  OutputDir = (char *) argv[0];
  Num = *(int *) argv[1];

  GroupLen = (int *) argv[2];
  GroupFileNr = (int *) argv[3];
  GroupNr = (int *) argv[4];

  sprintf(buf, "%s/group_tab_%03d.0", OutputDir, Num);
  if(!(fd = fopen(buf, "r")))
    {
      printf("can't open file `%s'\n", buf);
      return -1;
    }

  fread(&Ngroups, sizeof(int), 1, fd);
  fread(&Nids, sizeof(int), 1, fd);
  fread(&TotNgroups, sizeof(int), 1, fd);
  fread(&NTask, sizeof(int), 1, fd);
  fclose(fd);


  for(filenr = 0, count = 0; filenr < NTask; filenr++)
    {
      sprintf(buf, "%s/group_tab_%03d.%d", OutputDir, Num, filenr);
      if(!(fd = fopen(buf, "r")))
	{
	  printf("can't open file `%s'\n", buf);
	  return -1;
	}

      fread(&Ngroups, sizeof(int), 1, fd);
      fread(&Nids, sizeof(int), 1, fd);
      fread(&TotNgroups, sizeof(int), 1, fd);
      fread(&NTask, sizeof(int), 1, fd);

      fread(&GroupLen[count], sizeof(int), Ngroups, fd);

      for(i = 0; i < Ngroups; i++)
	{
	  GroupFileNr[i + count] = filenr;
	  GroupNr[i + count] = i;
	}

      count += Ngroups;

      fclose(fd);
    }

  temp = malloc(sizeof(cat_data) * TotNgroups);

  for(i = 0; i < TotNgroups; i++)
    {
      temp[i].len = GroupLen[i];
      temp[i].file = GroupFileNr[i];
      temp[i].offset = GroupNr[i];
    }

  qsort(temp, TotNgroups, sizeof(cat_data), id_sort_groups);

  for(i = 0; i < TotNgroups; i++)
    {
      GroupLen[i] = temp[i].len;
      GroupFileNr[i] = temp[i].file;
      GroupNr[i] = temp[i].offset;
    }

  free(temp);

  return TotNgroups;
}

int id_sort_groups(const void *a, const void *b)
{
  if(((cat_data *) a)->len > ((cat_data *) b)->len)
    return -1;

  if(((cat_data *) a)->len < ((cat_data *) b)->len)
    return +1;

  return 0;
}


int get_hash_table_size(int argc, void *argv[])
{
  int Num, dummy;
  int *NFiles;
  io_header header;
  char *OutputDir, *Snapbase;
  char buf[1000];
  FILE *fd;

  OutputDir = (char *) argv[0];
  Num = *(int *) argv[1];
  Snapbase =  (char *) argv[2];

  NFiles = (int *) argv[3];

  sprintf(buf, "%s/%s_%03d.0", OutputDir, Snapbase, Num);
  if(!(fd = fopen(buf, "r")))
    {
      printf("can't open file `%s'\n", buf);
      return -1;
    }

  fread(&dummy, sizeof(int), 1, fd);
  printf("dummy=%d\n", dummy);

  fread(&header, sizeof(io_header), 1, fd);
  fread(&dummy, sizeof(int), 1, fd);

  printf("dummy=%d\n", dummy);
  fclose(fd);

  *NFiles = header.num_files;

  return header.hashtabsize;
}


int get_hash_table(int argc, void *argv[])
{
  int Num, dummy, filenr, NTask;
  int i, firstcell, lastcell;
  io_header header;
  char *OutputDir, *Snapbase;
  char buf[1000];
  FILE *fd;
  int *Hashtable;
  int *Filetable;
  int *LastHashCell;
  int *NInFiles;

  OutputDir = (char *) argv[0];
  Num = *(int *) argv[1];
  Snapbase =  (char *) argv[2];

  Hashtable = (int *) argv[3];
  Filetable = (int *) argv[4];
  LastHashCell = (int *) argv[5];
  NInFiles = (int *) argv[6];

  NTask = 1;			/* will be taken from header */

  for(filenr = 0; filenr < NTask; filenr++)
    {
      sprintf(buf, "%s/%s_%03d.%d", OutputDir, Snapbase, Num, filenr);
      if(!(fd = fopen(buf, "r")))
	{
	  printf("can't open file `%s'\n", buf);
	  return -1;
	}
      fread(&dummy, sizeof(int), 1, fd);
      fread(&header, sizeof(io_header), 1, fd);
      fread(&dummy, sizeof(int), 1, fd);
      NTask = header.num_files;

      /* skip positions */
      fread(&dummy, sizeof(int), 1, fd);
      fseek(fd, dummy, SEEK_CUR);
      fread(&dummy, sizeof(int), 1, fd);

      /* skip velocities */
      fread(&dummy, sizeof(int), 1, fd);
      fseek(fd, dummy, SEEK_CUR);
      fread(&dummy, sizeof(int), 1, fd);

      /* skip IDs */
      fread(&dummy, sizeof(int), 1, fd);
      fseek(fd, dummy, SEEK_CUR);
      fread(&dummy, sizeof(int), 1, fd);

      fread(&dummy, sizeof(int), 1, fd);
      fread(&firstcell, sizeof(int), 1, fd);
      fread(&lastcell, sizeof(int), 1, fd);
      fread(&dummy, sizeof(int), 1, fd);

      LastHashCell[filenr] = lastcell;
      NInFiles[filenr] = header.npart[1];

      if(firstcell < 0 || firstcell >= header.hashtabsize || lastcell < 0 || lastcell >= header.hashtabsize)
	{
	  printf("bummer!\n");
	  return -1;
	}

      fread(&dummy, sizeof(int), 1, fd);
      fread(&Hashtable[firstcell], sizeof(int), lastcell - firstcell + 1, fd);
      fread(&dummy, sizeof(int), 1, fd);

      for(i = 0; i < lastcell - firstcell + 1; i++)
	Filetable[firstcell + i] = filenr;

      fclose(fd);
    }

  return 0;
}




long long get_group_coordinates(int argc, void *argv[])
{
  int Num, dummy, NTask, ind;
  int i, j, n;
  io_header header;
  IDL_STRING *idl_s;
  char *OutputDir, *PostProcDir, *Snapbase;
  char buf[1000];
  FILE *fd;
  int *Hashtable, *LastHashCell;
  int *Filetable;
  int *NInFiles;
  int hashtabsize, GroupNr, FileNr, GroupLen, Ngroups, TotNgroups, count, Nids;
  int len, offset;
  float *Pos, *Vel;
  float *Sx, *Sy, *Sz;
  double sx, sy, sz;
  double refx, refy, refz;
  float *pos_read, *vel_read;
  int hash_key;
  unsigned long long id;
  unsigned long long *ids, *id_read;
  ids_data  *idsgroup;

  idl_s = (IDL_STRING *) argv[0];
  OutputDir = idl_s->s;

  idl_s = (IDL_STRING *) argv[1];
  PostProcDir = idl_s->s;

  Num = *(int *) argv[2];
  idl_s = (IDL_STRING *) argv[3];
  Snapbase = idl_s->s;

  Hashtable = (int *) argv[4];
  Filetable = (int *) argv[5];
  hashtabsize = *(int *) argv[6];
  LastHashCell = (int *) argv[7];
  NInFiles = (int *) argv[8];
  GroupNr = *(int *) argv[9];
  FileNr = *(int *) argv[10];
  GroupLen = *(int *) argv[11];
  Pos = (float *) argv[12];
  Vel = (float *) argv[13];
  Sx = (float *) argv[14];
  Sy = (float *) argv[15];
  Sz = (float *) argv[16];

  sprintf(buf, "%s/group_tab_%03d.%d", OutputDir, Num, FileNr);
  if(!(fd = fopen(buf, "r")))
    {
      printf("can't open file `%s'\n", buf);
      return -1;
    }

  fread(&Ngroups, sizeof(int), 1, fd);
  fread(&Nids, sizeof(int), 1, fd);
  fread(&TotNgroups, sizeof(int), 1, fd);
  fread(&NTask, sizeof(int), 1, fd);
  /* skip group-len table */
  fseek(fd, sizeof(int) * Ngroups, SEEK_CUR);
  fseek(fd, sizeof(int) * GroupNr, SEEK_CUR);
  fread(&offset, sizeof(int), 1, fd);
  fclose(fd);

  idsgroup = malloc(GroupLen * sizeof(ids_data));
  ids = malloc(GroupLen * sizeof(long long));


  sprintf(buf, "%s/sub_ids_%03d.%d", PostProcDir, Num, FileNr);
  if(!(fd = fopen(buf, "r")))
    {
      printf("can't open file `%s'\n", buf);
      return -1;
    }
  fread(&Ngroups, sizeof(int), 1, fd);
  fread(&Nids, sizeof(int), 1, fd);
  fread(&TotNgroups, sizeof(int), 1, fd);
  fread(&NTask, sizeof(int), 1, fd);

  fseek(fd, sizeof(long long) * offset, SEEK_CUR);
  fread(ids, sizeof(long long), GroupLen, fd);
  fclose(fd);

  for(i = 0; i < hashtabsize; i++)
    Filetable[i] <<= 1;


  for(i = 0, count = 0; i < GroupLen; i++)
    {
      hash_key = (ids[i] >> 34);

      if(hash_key >= hashtabsize)
	{
	  printf("bummer\n");
	  return -1;
	}

      if((Filetable[hash_key] & 1) == 0)
	{
	  Filetable[hash_key] |= 1;

	  if(hash_key != LastHashCell[Filetable[hash_key] >> 1])
	    count += Hashtable[hash_key + 1] - Hashtable[hash_key];
	  else
	    count += NInFiles[Filetable[hash_key] >> 1] - Hashtable[hash_key];
	}
    }

  pos_read = malloc(3 * count * sizeof(float));
  vel_read = malloc(3 * count * sizeof(float));
  id_read = malloc(count * sizeof(long long));


  for(i = 0, count = 0; i < hashtabsize; i++)
    {
      if((Filetable[i] & 1))
	{
	  sprintf(buf, "%s/%s_%03d.%d", OutputDir, Snapbase, Num, Filetable[i] >> 1);
	  if(!(fd = fopen(buf, "r")))
	    {
	      printf("can't open file `%s'\n", buf);
	      return -1;
	    }
	  fread(&dummy, sizeof(int), 1, fd);
	  fread(&header, sizeof(io_header), 1, fd);
	  fread(&dummy, sizeof(int), 1, fd);

	  BoxSize = header.BoxSize;

	  fread(&dummy, sizeof(int), 1, fd);
	  fseek(fd, 3 * Hashtable[i] * sizeof(float), SEEK_CUR);

	  if(i != LastHashCell[Filetable[i] >> 1])
	    len = Hashtable[i + 1] - Hashtable[i];
	  else
	    len = NInFiles[Filetable[i] >> 1] - Hashtable[i];

	  fread(&pos_read[3 * count], sizeof(float), 3 * len, fd);

	  fclose(fd);


	  if(!(fd = fopen(buf, "r")))
	    {
	      printf("can't open file `%s'\n", buf);
	      return -1;
	    }
	  fread(&dummy, sizeof(int), 1, fd);
	  fread(&header, sizeof(io_header), 1, fd);
	  fread(&dummy, sizeof(int), 1, fd);


	  fread(&dummy, sizeof(int), 1, fd);
	  fseek(fd, dummy, SEEK_CUR);
	  fread(&dummy, sizeof(int), 1, fd);


	  fread(&dummy, sizeof(int), 1, fd);
	  fseek(fd, 3 * Hashtable[i] * sizeof(float), SEEK_CUR);

	  if(i != LastHashCell[Filetable[i] >> 1])
	    len = Hashtable[i + 1] - Hashtable[i];
	  else
	    len = NInFiles[Filetable[i] >> 1] - Hashtable[i];

	  fread(&vel_read[3 * count], sizeof(float), 3 * len, fd);

	  fclose(fd);

	  count += len;
	}
    }


  for(i = 0, count = 0; i < hashtabsize; i++)
    {
      if((Filetable[i] & 1))
	{
	  sprintf(buf, "%s/%s_%03d.%d", OutputDir, Snapbase, Num, Filetable[i] >> 1);
	  if(!(fd = fopen(buf, "r")))
	    {
	      printf("can't open file `%s'\n", buf);
	      return -1;
	    }
	  fread(&dummy, sizeof(int), 1, fd);
	  fread(&header, sizeof(io_header), 1, fd);
	  fread(&dummy, sizeof(int), 1, fd);

	  /* skip positions */
	  fread(&dummy, sizeof(int), 1, fd);
	  fseek(fd, dummy, SEEK_CUR);
	  fread(&dummy, sizeof(int), 1, fd);

	  /* skip velocities */
	  fread(&dummy, sizeof(int), 1, fd);
	  fseek(fd, dummy, SEEK_CUR);
	  fread(&dummy, sizeof(int), 1, fd);

	  fread(&dummy, sizeof(int), 1, fd);
	  fseek(fd, Hashtable[i] * sizeof(long long), SEEK_CUR);

	  if(i != LastHashCell[Filetable[i] >> 1])
	    len = Hashtable[i + 1] - Hashtable[i];
	  else
	    len = NInFiles[Filetable[i] >> 1] - Hashtable[i];

	  fread(&id_read[count], sizeof(long long), len, fd);

	  count += len;
	  fclose(fd);
	}
    }

  for(i = 0; i < GroupLen; i++)
    {
      idsgroup[i].id = (ids[i] & ((((long long) 1) << 34) - 1));
      idsgroup[i].rank = i;
    }

  for(i = 0; i < count; i++)
    id_read[i] = ((id_read[i] & ((((long long) 1) << 34) - 1)) << 29) + i;

  qsort(idsgroup, GroupLen, sizeof(ids_data), id_sort_idsgroup);
  qsort(id_read, count, sizeof(long long), id_sort_compare_key);


  if(count < GroupLen)
    {
      printf("PROBLEM! count=%d GroupLen=%d\n", count, GroupLen);
      printf("Something seems to be wrong here=!\n");
    }

  for(i = 0, n = 0; i < GroupLen && n < count; i++)
    {
      id = (id_read[n] >> 29);

      while(n < count && id < idsgroup[i].id)
	{
	  n++;
	  id = (id_read[n] >> 29);
	}

      if(id != idsgroup[i].id)
	{
	  printf("We have a mismatch! (i=%d) something is wrong here.\n", i);
	}

      ind = (id_read[n] & ((1 << 29) - 1));

      for(j = 0; j < 3; j++)
	{
	  Pos[idsgroup[i].rank * 3 + j] = pos_read[ind * 3 + j];
	  Vel[idsgroup[i].rank * 3 + j] = vel_read[ind * 3 + j];
	}
    }

  sx = sy = sz = 0;
  refx = Pos[0];
  refy = Pos[1];
  refz = Pos[2];

  for(i = 0; i < GroupLen; i++)
    {
      Pos[i * 3 + 0] = fof_periodic(Pos[i * 3 + 0] - refx);
      Pos[i * 3 + 1] = fof_periodic(Pos[i * 3 + 1] - refy);
      Pos[i * 3 + 2] = fof_periodic(Pos[i * 3 + 2] - refz);
    }

  for(i = 0; i < GroupLen; i++)
    {
      sx += Pos[i * 3 + 0];
      sy += Pos[i * 3 + 1];
      sz += Pos[i * 3 + 2];
    }

  sx /= GroupLen;
  sy /= GroupLen;
  sz /= GroupLen;

  for(i = 0; i < GroupLen; i++)
    {
      Pos[i * 3 + 0] -= sx;
      Pos[i * 3 + 1] -= sy;
      Pos[i * 3 + 2] -= sz;
    }

  for(i = 0; i < hashtabsize; i++)
    Filetable[i] >>= 1;

  free(id_read);
  free(pos_read);
  free(vel_read);
  free(ids);
  free(idsgroup);


  *Sx = fof_periodic_wrap(sx + refx);
  *Sy = fof_periodic_wrap(sy + refy);
  *Sz = fof_periodic_wrap(sz + refz);

  return 0;
}







double fof_periodic_wrap(double x)
{
  while(x >= BoxSize)
    x -= BoxSize;

  while(x < 0)
    x += BoxSize;

  return x;
}


double fof_periodic(double x)
{
  if(x >= 0.5 * BoxSize)
    x -= BoxSize;

  if(x < -0.5 * BoxSize)
    x += BoxSize;

  return x;
}


int id_sort_idsgroup(const void *a, const void *b)
{
  if((((ids_data *)a)->id) < (((ids_data *)b)->id))
    return -1;

  if((((ids_data *)a)->id) > (((ids_data *)b)->id))
    return +1;

  return 0;
}


int id_sort_compare_key(const void *a, const void *b)
{
  if(*((long long *) a) < *((long long *) b))
    return -1;

  if(*((long long *) a) > *((long long *) b))
    return +1;

  return 0;
}
